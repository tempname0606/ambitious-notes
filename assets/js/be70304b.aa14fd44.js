"use strict";(self.webpackChunkambitious_notes=self.webpackChunkambitious_notes||[]).push([[50],{824:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>t,metadata:()=>c,toc:()=>l});var r=i(4848),s=i(8453);const t={title:"Theory",description:"What the fuck is recursion?"},o=void 0,c={id:"recursion/theory",title:"Theory",description:"What the fuck is recursion?",source:"@site/docs/recursion/theory.md",sourceDirName:"recursion",slug:"/recursion/theory",permalink:"/ambitious-notes/recursion/theory",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Theory",description:"What the fuck is recursion?"},sidebar:"tutorialSidebar",previous:{title:"Recursion",permalink:"/ambitious-notes/category/recursion"},next:{title:"Trees",permalink:"/ambitious-notes/category/trees"}},a={},l=[{value:"What is recursion?",id:"what-is-recursion",level:2},{value:"Types of Recursion",id:"types-of-recursion",level:2},{value:"Tail Recursion",id:"tail-recursion",level:3},{value:"Head Recursion",id:"head-recursion",level:3},{value:"Tree Recursion",id:"tree-recursion",level:3},{value:"Indirect Recursion",id:"indirect-recursion",level:3}];function u(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"what-is-recursion",children:"What is recursion?"}),"\n",(0,r.jsx)(n.p,{children:"In plain words, recursion is what you get when you want to flex to everyone around you whilst you're trying to hide the smokes coming out of your stack cause your code cause a stack overflow. Normal people use loops and stacks but nooooo, you have to be a 1337c0d3 kid to solve your fancy tree and graph traversal problems hehe."}),"\n",(0,r.jsx)(n.p,{children:"Anyways, I digress. A recursive function is a function that calls itself."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"private int func(int n) {\n    if (n == 0) return 0;\n    System.out.println(n); // prints numbers from n to 0\n    return func(n - 1);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Recursive functions have two phases, the ",(0,r.jsx)(n.strong,{children:"ascending"})," and the ",(0,r.jsx)(n.strong,{children:"descending"}),". ",(0,r.jsx)(n.strong,{children:"Ascending"})," phase is the phase before the recursive call whereas ",(0,r.jsx)(n.strong,{children:"descending"})," is the phase after the recursive call."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"private void func(int n) {\n    if (n > 0)\n    // Any calls here are part of the ascending phase\n    func(n - 1) + n; // <--- + n will be done at descending phase as it is after the method call\n    // Any calls here are part of the descending phase\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"types-of-recursion",children:"Types of Recursion"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Tail Recursion"}),"\n",(0,r.jsx)(n.li,{children:"Head Recursion"}),"\n",(0,r.jsx)(n.li,{children:"Tree Recursion"}),"\n",(0,r.jsx)(n.li,{children:"Indirect Recursion"}),"\n",(0,r.jsx)(n.li,{children:"Nested Recursion"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"tail-recursion",children:"Tail Recursion"}),"\n",(0,r.jsxs)(n.p,{children:["If a recursive function's last statement is the recursive call then this is a ",(0,r.jsx)(n.strong,{children:"Tail Recursive Function"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"private void fun(int n) {\n    if (n > 0) {\n        System.out.println(n);\n        fun(n - 1);\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This means that all the operations prior to the recursive call will be performed at calling time (",(0,r.jsx)(n.strong,{children:"ascending"}),") and no operations will be performed at returning time (",(0,r.jsx)(n.strong,{children:"descending"}),")."]}),"\n",(0,r.jsx)(n.h3,{id:"head-recursion",children:"Head Recursion"}),"\n",(0,r.jsxs)(n.p,{children:["If a recursive function's first statement is the recursive call then this is a ",(0,r.jsx)(n.strong,{children:"Head Recursive Function"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"private void fun(int n) {\n    if (n > 0) {\n        fun(n - 1);\n        System.out.println(n);\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This means that all the operations after the recursive call will be performed at returning time (",(0,r.jsx)(n.strong,{children:"descending"}),") and no operations will be performed at calling time (",(0,r.jsx)(n.strong,{children:"ascending"}),")."]}),"\n",(0,r.jsx)(n.h3,{id:"tree-recursion",children:"Tree Recursion"}),"\n",(0,r.jsxs)(n.p,{children:["If a recursive function is calling itself more than one time then it is a ",(0,r.jsx)(n.strong,{children:"Tree Recursive Function"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"private void fun(int n) {\n    if (n > 0) {\n        System.out.println(n);\n        fun(n - 1);\n        fun(n - 1);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"indirect-recursion",children:"Indirect Recursion"}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.strong,{children:"Indirect Recursion"}),", there may be a function ",(0,r.jsx)(n.strong,{children:"A"})," which may call a function ",(0,r.jsx)(n.strong,{children:"B"})," which may then call a function ",(0,r.jsx)(n.strong,{children:"C"}),", all that in a circular fashion."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"private void fun1(int n) {\n    if (n > 0) {\n        System.out.println(n);\n        fun2(n - 1);\n    }\n}\n\nprivate void fun2(int n) {\n    if (n > 0) {\n        System.out.println(n);\n        fun1(n - 2);\n    }\n}\n"})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var r=i(6540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);